2018-8-7 22:57--23:46
### 序言
神在细节之中。

### 代码猴子与童子军军规
“写整洁的代码， 需要遵循大量的小技巧”
Test Obsessed(沉迷测试)

### 前言
书分3部分
1. 编写整洁代码的原则
1. 最需要花功夫， 包括几个复杂性不断增加的案例研究
1. 列出上述案例研究中得到的启示和灵感

----------

#### 第一章 整洁代码
Object Mentor 整洁代码流派
“读与写花费时间的比例超过10:1”
“写新代码时， 我们一直在读旧代码”
“编写代码的难度， 取决于读周边代码的难度”
“让营地比你来时更干净”

1.1
永远抛不掉代码， 归置良好的需求就像代码, 易于证实， 也能作为代码的可执行测试来使用

1.2
“稍后等于用不”， 从小处着手改善代码。糟糕的代码不止拖慢进度， 还会毁了公司

1.3
混乱--加入新人企图加快进度--新人理解需要时间--生产率反而降低
程序员如同医生， 直接决定软件的质量， 遵循不了解混乱风险的经理的意愿， 也是不专业的
制作混乱无助于赶上进度， 唯一的方法是： 始终尽可能保持代码整洁
需要有“代码感”， 需要遵循大量的小技巧和进行大量的练习
整洁代码： 愉悦， 如同阅读散文， “干净利落的抽象”， 整洁系于测试之上， 小块的代码， 功能单一， 没有重复的代码， 明确、简单、有力

1.4
代码也有流派， 这本书是对象导师（Object Mentor）整洁代码流派
并没有最好的流派， 需要取各家至所长

----------


2018-8-8 12:36--12:42 22:00--22:40
#### 第二章 有意义的命名
如果需要注释, 命名就不算名副其实

2.2
命名需要让人容易理解和修改代码
尽量语义化

2.3
避免误导， 不要使用与本意相悖的词， 不要使用太长的名字， O 和 l不要使用

2.4
做有意义的区分
不要使用数字系列命名， Info和data等等含糊的名称不要使用， 例如customerInfo和customer并没有区别

2.5
使用读得出来的名称
使用单词而非一些缩写

2.6
使用可搜索的名称
例如一些常量使用MAX_VALUE等等有意义的名称代替

2.7
避免使用编码， 因为编码也算一种语言， 会增加理解的负担， 例如
- 匈牙利标记法
- 成员前缀
- 接口和实现， 例如iFactory不如Factory好

2.8
避免思维映射
专业术语可以放心使用， “明确是王道”

2.9
类名不应该是动词， 应该是名词或者名词短语

2.10
方法名应该是动词或者动词短语

2.11
不要使用俚语， 使用明确的名称

2.12
一个概念对应一个词， fetch, retrieve, get等等宽泛的词， 少用

2.13
别用双关语
一个单词只用于一个目的

2.14
只有程序员才读你的代码， 放心使用专业词汇

2.15
使用源自问题领域的名称

2.16
添加有意义的语境， 表示相关操作的变量放在一起， 可以自然而然地知道他们的用法

2.17
不要添加没用的语境
当短名称足够好的时候， 使用短名称即可

----------

2018-8-8 22:41--23:00 2018-8-9 8:30--9:00  12:43--13:00  8-9 21:20--22:55
#### 第三章 函数
函数的第一规则是短小， 第二条规则是， 还要更短小
if， else, while等语句， 代码块应该只有一行
函数应该做一件事， 做好这件事， 只做这件事
自顶向下读代码
最理想的参数数量是零
大师级程序员把系统当作故事来讲， 而不是当作程序来写
真正的目标在于讲述系统的故事， 而你编写的函数必须干净利落地拼装在一起， 帮助你讲故事

3.1
短小
函数20行封顶最佳
每个函数都只说一件事, 而且, 每个函数都依序把你带到下一个函数
代码块应该只有一行

3.2
只做一件事
可以将事情用TO起头段落来描述, 如果可以描述清楚(都在同一个抽象层里面), 这个就只是一个事情, 应该由一个函数来做

3.3
每个函数一个抽象层级
函数中不要混杂不同的抽象层级, 否则容易让人迷惑
最后每个函数后面都跟着下一抽象层级的函数, 这样可以自顶向下阅读代码, 便于理解
最上层的是最大的抽象层, 紧接的是这个层的分解和实现....最下层是最后的具体细节, 类似金字塔原则

3.4
switch语句
switch天生要做多件事, 需要尽量确保switch都埋藏在较低的层级, 而且永远不要重复, 如果是支持多态的语言, 可以使用多态来实现
对于switch语句, 如果只出现一次, 可以埋到创建多态对象的工厂里面, 隐藏在某个继承关系中, 在系统其他部分看不到

3.5
使用描述行名称
函数越短小, 功能越集中, 越容易取一个好名字
长而具有描述性的名字, 比短而令人费解的好, 但是, 如果可以, 太长的名字往往表示有多个抽象层, 可以拆分成多个短小的函数

3.6
函数参数
最好不过2个参数
- 一元参数, 参数是被处理的数值或对象, 或者是event
- 标识参数, 不要向函数传入boolean, 传入boolean即对外说明, 这个函数不止做一件事
- 二元参数, 最好是这两个参数是表示一个事物的, 或者是测试函数的输入值和期望值
- 不要使用三元参数
- 再多的参数, 可以将其组合成对象, 或者可变参数

3.7
函数应该无副作用, 因为函数本来就应该只做一件事
如果有副作用, 则可能带来时序性耦合
应避免使用输出参数, 如果函数必须要修改某种状态, 就修改所属对象的状态

3.8
函数要么做什么事, 要么回答什么事, 只能选择一个
if (set("username", "uncleBob") {}, if语句块执行的条件是一个操作所返回的结果, 这样会增加阅读的困难

3.9
使用异常替代返回错误码
使用异常， 可以将处理错误的代码和主代码分离， 简化程序，  同时， 需要注意以下的情况
- 抽离try/catch代码块， try/catch把错误处理和正常流程混为一谈， 这样的程序至少需要做两件事， 这是不对的， 最好把错误处理分离出来， 形成一个函数
- 错误处理就是一件事
- 依赖磁铁， 定义所有错误码的类通常被大部分类引用和依赖， 如果出现新的错误码， 就要修改， 而且， 新的类都要复用旧的错误码

3.10
DRY

3.11
结构化编程
依照这个规范， 每个函数只应该有一个return， 循环里面不能有break或者continue， 永远不能有goto， 但是， 对于足够短的函数， 偶尔有多个return， break或者continue， 影响不大

3.12
如何写出符合以上要求的函数
一开始不用苛求， 一遍遍打磨， 拆分， 重构

----------

#### 第四章 注释
如果编程语言有足够的表达力， 就不那么需要注释
注释的恰当用法是， 弥补我们在用代码表达意图时遭遇的失败， 需要注意， 是失败， 因为注释会说谎， 程序变的时候， 注释并不一定会随之而变
有时间写注释， 不如用来写好代码， 写不需要注释的代码
用代码来描述事情


----------

2018-8-10 8:46--8:59  2018-8-12 8:33--8:57
#### 第五章 格式
代码格式很重要， 关乎沟通， 必须严肃对待
向报纸学习
每个空白行都是一个线索， 标识出一个新的独立概念
同一概念的代码， 垂直距离应该尽可能近， “避免眼球上下找适合的代码”
一行代码里面， 关系密切的元素， 横向距离应该要小， 需要强调的操作， 应该在其前后都加一个空格
缩进可以显示代码的作用域
建立并适应团队的代码风格

5.1
格式的目的
“让代码能工作”, 固然是很重要的事情, 同时, 代码格式关乎沟通, 而沟通, 是专业开发者的头等大事

5.2
垂直格式
使用大多数为200行, 最长500行的单个文件, 可以构造出出色的系统
代码也是信息, 报纸也是信息的载体, 聪明的做法都是相通的, 写代码可以借鉴报纸的写法, 金字塔原理, 要事突出, 简明扼要, 信息分层等等
使用空白行分割不同的函数, 概念, 相对地, 位于同一概念的函数、语句、变量等等, 请尽量靠近
代码块的变量, 可以统一写在靠前的位置
函数也应该按照顺序放置, 例如按照调用的顺序

5.3
横向格式
短代码行比较受人喜爱, 建议一行在80个字符左右
横向使用空格的情况
- 用空格把相关性较弱的事物隔开
- 建议不在函数名和左圆括号之间加空格
水平对齐的情况, 一般不需要太在意
缩紧, 可以显示层级和继承, 说明作用域范围, 需要务必遵守
即使是空语句, 也最好加一个{}

5.4
团队规则
一组开发者应该认同一种格式风格, 如果风格不统一, 会增加代码理解的困难

----------

2018-8-12 9:00--9:26  2018-8-14 20:51--21:52
#### 第六章 对象和数据结构
数据抽象的目的是什么? 变量私有的目的是什么?
用户无需了解数据的实现就能操作数据本体

对象把数据隐藏于抽象之后, 暴露操作数据的函数; 数据结构暴露其数据, 没有提供有意义的函数
过程式代码便于在不改动既有数据结果的前提下添加新函数, 面向对象代码便于在不改动既有函数的前提下添加新类
对于JavaScript, 是基于对象的语言, 函数是第一等公民, 也许不太适合使用过程式

The Law of Demeter, 模块不应了解它所操作对象的内部情形
方法不应调用由任何函数返回的对象的方法, “只跟朋友谈话, 不和陌生人谈话”
应该避免使用混杂模式写函数, 例如getter和setter方法等等, 如果仅仅是一个数据结构的话

6.1
数据抽象
使得代码适应更多情况
并不只是用接口或者setter/getter就可以, 需要思考, 用最好的方式呈现这个对象包含的数据

6.2
数据结构--对象, 数据--操作(行为), 他们是对立的, 互有优点, 不同的适用场景

6.3
不要和陌生人说话, 对象不应该通过setter/getter暴露其内部结构, 方法不应该调用其他函数返回的对象的方法

6.4
数据传输对象
DTO, BEAN, 最精炼的数据结构, 只有公共变量, 没有函数
拥有setter和getter操作私有变量
Active Record??

6.5
应该根据需要, 选择对象式或者过程式

----------

2018-8-14 21:54--22:49
#### 第七章 错误处理
错误处理很重要, 但是如果它搞乱了代码逻辑, 就是错误的做法

遇到错误的时候, 最后抛出一个异常, 不让其扰乱代码主逻辑

可控异常的代价是违反开放/闭合原则
对于一般的应用开发, 使用可控异常的成本过高

不要返回null值, 也不要传递null值

错误处理和代码整洁并不冲突, 而错误应该独立地, 隔离地被处理, 这样就可以写出整洁而健壮的代码

7.1
使用异常而非返回码
出现错误的时候返回状态码或者错误标识, 会扰乱代码主流程, 而抛出异常, 可以保证主流程代码位置上和逻辑上的连贯

7.2
先写Try-Catch-Finally语句
相当于定义好了事务和错误的区域

7.3
使用不可控异常

7.4
给出异常发生的环境说明
即使调试器可以给出错误发生的位置, 但是却无法给出错误发生的原因, 所以, 应该在抛出错误的时候, 附带一系列的环境说明, 包括失败操作和类型

7.5
依调用者需要定义异常类
不要死板地处理异常类, 应该分类, 主次分明, 不需要写重复的代码

7.6
定义常规流程
可以使用特例模式, 创建一个类或者对象, 用来处理特例, 这样在代码中, 特例就不会被视为异常行为, 而是主流程的一个分支

7.7, 7.8
关于null
不要返回null, 尽可能不要写需要检查null的代码, 不要传递null值, 参数不要有null

----------

2018-8-15 08:41--09:00
#### 第八章 边界
在使用第三方代码的时候, 需要控制好其使用边界

----------

2018-8-16 21:49--22:48
#### 第九章 单元测试
测试与生产代码一起编写
测试代码和生产代码一样重要, 测试也需要遵从代码规范, 脏测试等同于没有测试
在单元测试中 可读性比生产代码还重要

TDD三定律
- 编译不通过单元测试前, 不可编写生产代码
  确保了解需求的前提下, 好的单元测试覆盖了全部情况
- 只可编写可以编译的单元测试, 不能编译也算不通过
  单元测试也需要正确的代码格式和规范
- 只可编写刚好足以通过当前失败测试的生产代码
  不能写得太多

整洁的测试三要素: 可读性x3

构造-操作-检验, 测试模式
单元测试也应该遵从业务代码的规范, 同时, 可以把测试细节, 调用的API, 函数和工具代码等等包起来, 写成有意义的测试函数, 让读测试的人应该都能很快搞清楚状况, 不至于被细节误导或吓倒

每个测试一个断言
given-when-then约定??
模版方法测试模式
每个测试一个概念

整洁测试的原则: 快速, 独立, 可重复, 自我验证, 及时

----------

2018-8-17  8:34--9:00
#### 第十章 类
单一权责原则, 类或者模块, 应该只有一条加以修改的理由, 即只有一个权责

系统应该由许多短小的类而不是少量巨大的类组成

如果一个类中的每个变量都被每个方法所使用, 则这个类具有最大的内聚力性, 也就是说, 变量的定义和使用应该恰如其分, 方法的定义应该最大限度地只使用内部变量, 不受外部变量影响

当类丧失了内聚性, 就应该拆分