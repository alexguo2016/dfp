# 你不知道的 JavaScript 中卷

## 第一部分 类型和语法

可能这部分的东西比较琐碎...

### 第一章 类型

类型是值的内部特征, 它定义了值的行为, 以使其区别与其他值.

js 有七种内置的类型: null, undefined, boolean, number, string, object, symbol.
需要注意的是 typeof, typeof null == “object”, typeof undefined == "undefined", typeof symbol = "symbol"

js 中, 变量是没有类型的, 和 java 等等语言相区别

undefined 和 not defined 是两回事, 前者是有这个变量, 没有定义值, 后者是没有这个变量.

## 第二部分 异步和性能

异步编程--回调函数--promise--生成器

### 第一章 异步: 现在与将来

程序的一部分现在运行, 程序的另外一部分则在将来运行, 现在和将来之间有一些空隙, 在这段空隙中, 程序没有活跃执行.

#### 分块的程序

最常见的块单位是函数.
例如标准的 ajax 函数, 它不是同步的, 一般没有返回值, 只是一个将来运行的程序, 将来才有结果.
从现在到将来的“等待”, 最佳的方法是使用回调函数. 但是, 使用回调函数的时候, 需要注意, 程序执行的结果, 例如:

```js
console.log(233);
setTimeout(function() {
  console.log("last");
}, 0);
console.log(466);
// 输出的结果是 233 466 last, 这里的setTimeout设置了一个定时器, 是将来的某个事件, 可是, 这个事件会在当前tick走完之后才会被执行
```

同时, 需要注意的是, 我们在使用 console.log 的时候, 其实也是异步的, 因为其中使用到的是控制台 I/O, 比较耗时, 不同的浏览器有不同的实现, 有时候可能不会得到我们想要的结果, 所以, 调试的时候, 最好还是使用断点.

#### 事件循环

js 引擎本身所做的只不过是在需要的时候, 在给定的任意时刻执行程序中的单个代码块, 可是, 这个“需要”, 是谁需要?
js 引擎有一个叫做“事件循环”的机制. js 引擎本身并没有事件的概念, 只是一个按需执行 js 代码的环境.“事件”(js 代码执行)调度总是由包含 js 引擎的环境进行的.
什么是事件循环?
原理其实就是一个 while 循环, 每一个时刻(tick)运行它里面事件 array 的所有事件, 如果这个 tick 的事件完成了, 可以执行下一个 tick 的循环. 例如, 如果我们 setTimeout 了一个事件(回调函数), 则会在前一个 tick 完成之后, 任意的时间插入到下一个 tick 的循环中, 然后被执行.

#### 并行线程

异步和并行的意义完全不同. 异步是关于现在和将来的事件间隙, 而并行是关于能够同时发生的事情.
js 是单线程的, 它拥有完整运行特性, 每一步都是原子性的. 由于这个特性, 它比并行的多线程程序确定性要强一些, 但仍然有不确定性, 这个不确定性是由函数运行顺序带来的, 被称为竞态条件.

#### 并发

当多个并发进程之间没有交互的时候, 代码总是可以正常工作的.
如果它们之间有交互, 就会因为这些交互而产生意想不到的结果.
通过一些手段, 例如“门闩”, 可以解决一部分的这些问题.
另外的一种方法是“并发协作”, 重点是不再是通过共享作用域中的值进行交互, 是取一个长期运行的进程, 并将其分割成多个步骤或者多批任务来执行. 例如, 如果有一个任务, 需要读取数百万条数据, 可以这样

```js
var res = [];
function response(data) {
  var chuck = data.splick(0, 1000);
  res = res.concat(
    chuck.map(function(val) {
      return val * 2;
    })
  );
  if (data.length > 0) {
    setTimeout(function() {
      response(data);
    }, 0);
  }
}
// 这里, 其实就是一个tick执行1000个数据的处理
```

#### 任务

es6 中, 一个新的概念, 建立在事件循环之上, 叫做任务队列: 挂在事件循环队列的每个 tick 之后的一个队列. 在事件循环的每个 tick 中, 可能出现的异步动作, 不会导致一个完整的新事件添加到事件循环队列中, 而会在当前 tick 的任务队列末尾添加一个项目.

事件循环队列相当于在游乐场玩过一个游戏之后, 重新去到队伍的末尾排队(在下一个 tick 运行); 而任务队列则是, 玩过游戏之后, 插队接着玩(在这个 tick 运行).

promise 的异步特性是基于任务的! 和 setTimeout 基于事件循环有所不同.

#### 语句顺序

因为 js 是需要编译的, 所以, 实际运行的代码和写的时候有可能顺序不一样, 即使没有任何异步的情况下.

### 第二章 回调

#### continuation

回调函数包裹了程序的延续, 在当前程序的 tick 完成之后, 下一个 tick 中, 执行这个回调函数.

#### 顺序的大脑

我们大脑的工作方式, 有点类似事件循环队列. 在执行的时候, 不是多任务, 而是快速进行上下文切换.

#### 信任问题

使用回调函数的时候, 例如 ajax('...', function() {}), 其中 function 是我们自己需要执行的程序, 如果 ajax 是第三方的函数, 那么, 整个程序的控制权就到了第三方了, “控制反转”. 这个时候, 需要注意非常多的问题, 例如 ajax 调用 function 的次数, 时机, 发生异常时候的处理等等, 问题简直数不过来.

解决办法有多种, 例如 function 内进行输入值的判定, “error first 风格”, 调用验证等等, 通常, 比较有用的一个建议是: 永远异步调用回调.

### 第三章 promise

使用回调函数表达程序异步和管理并发的两个主要缺陷: 缺乏顺序性和可信度. 其根源在于控制反转.
如果可以将控制反转再反转, 第三方给我们提供了解其任务何时结束的能力, 然后我们自己的代码来决定下一步做什么, 那么, 就不存在上面的两个缺陷了.

#### 什么是 promise

##### 未来值

“一旦我需要的值准备好了, 我就用我的承诺值(value-promise)来换取这个值本身”.
或者, 这个值不能被准备好, 我得到的是一个 error 信息.

由于 promise 封装了依赖于时间的状态--等待底层值的完成或者拒绝, 所以 promise 本身是与时间无关的. 一旦 promise 决议, 它就永远保持在这个状态--不变值, 可以根据需求多次查看.

##### 完成事件

如果需要在 foo 函数结束之后进行一些操作, foo 可能需要一段时间才能完成, 我们可以这样做:

1. 使用典型的 js 风格, 使用回调函数的形式写入我们后面的操作, 这样做, 会发生“控制反转”, 主导权在 foo 函数
2. 使用 promise 风格, 主动侦听来自 foo 的事件, 反转控制反转, 主导权在我们写的 promise 里面

#### 具有 then 方法的鸭子类型 promise 的坑

首先, p instanceof Promise 是不足以作为检查方法的.
thenable 的函数(或者对象)都会被认为是 instanceof Promise 的.

不过, 经过实践, chrome 浏览器上面已经可以识别了, 例如 var a = {then: function(){}}, a instanceof Promise --> false.

#### promise 的信任问题

和使用回调函数相比, promise 有类似的信任问题吗? 例如调用次数, 时机, 参数和环境的传递, 错误和异常处理等等问题.
