# 你不知道的 JavaScript 上卷

## 第一部分 作用域和闭包

这套书的目的是: 知其然而知其所以然

13:50--14:34
P1--10

### 第一章, 作用域是什么

变量, 将状态带给了程序.
这里会讲到的是, 变量储存在哪里? 程序需要它们的时候, 如何找到它们?

#### 编译原理

事实上 javascript 是一门编译语言.
它不是提前编译的, 编译结果也不能在分布式系统中进行移植.

在编译语言的流程中, 源代码在执行之前的三个步骤--编译:

1. 分词/词法分析(Tokenizing/Lexing)
   将字符串分解成对语言来说有意义的代码块--词法单元(token), 例如: var a = 2-->var, a, =, 2, 空格

2. 解析/语法分析(Parsing)
   讲词法单元流(数组)转换成逐级嵌套组成的程序语法结构的树, 抽象语法树(AST).

3. 代码生成
   将 AST 转换成可执行的代码, 即转化成一族机器指令.

JavaScript 引擎比起上面的步骤要复杂. 例如在词法分析和代码生成阶段都有特定的步骤进行性能优化, 例如对冗余元素进行优化等等.
js 和其他编译语言不同的是, 他的编译在代码执行前的几微秒内完成, 所以它使用了例如 JIT 等等技术来保证性能最佳. 几乎是编译程序之后马上就执行.

#### 理解作用域

需要理解的角色

1. 引擎, 整个 js 程序的编译和执行过程
1. 编译器, 服装语法分析和代码生成等等
1. 作用域, 负责收集并维护所以声明的标识符, 确定标识符的访问权限

##### 例子, var a = 2

这个程序的伪代码是: 为一个变量分配内存, 命名为 a, 然后将值 2 保存进这个变量.

事实上, 编译器是这样做的

1. 遇到 var a, 先询问作用域中是否有一个 a 的变量, 如果有, 进行下一步, 如果没有, 会在 当前作用域 中声明一个新的变量, 命名为 a
2. 处理 a = 2, 这个赋值操作.引擎先问作用域, 当前的作用域集合里面是否有 a 变量, 有, 就使用它, 没有, 就继续查找 a

##### 编译器的工作

在刚刚的例子中, 引起执行程序的时候, 会通过查找变量 a 是否已经声明过, 这个过程中, 会对 a 进行 LHS 查询.
当变量在 赋值操作符的左侧的时候, 对其进行 LHS 查询, 在右侧的时候, 进行 RHS 查询.

- LHS, 试图找到变量的容器本身, 从而可以对其进行赋值, 例如 a = 2, 我们不关心 a 当前是什么, 只是取得他的地址
- RHS, “非左侧”, 就是简单地查找某个变量的值, retrieve his source value, 例如 console.log(a), 这里只是查找并取得 a 的值

##### 引擎和作用域之间的交互

```js
function foo(a) {
  console.log(a);
}
foo(2);
```

既有 LHS 也有 RHS
注意, foo(2)里面隐含了一个 a = 2 的 LHS

22:00--22:30
22:51--23:11
P10-20

#### 作用域嵌套

在实际情况中, 通常需要同时顾及几个作用域. 可能会出现作用域嵌套的情况.
如果在当前作用域无法找到某个变量, 就会去外层作用域中查找, 直到抵达最外层的作用域为止.

#### 异常

LHS 和 RHS 是不同的.
在非严格模式下, 如果 LHS 找不到变量名, 引擎会在全局作用域里面声明该变量.
但是, 如果 RHS, 当找不到对应的变量, 引擎就会抛出一个异常, ReferenceError, 如果对该变量进行不合理操作, 就会抛出 TypeError.

### 第二章 词法作用域

js 使用的是词法作用域, 也是大多数编程语言使用的, 其他语言例如 Bash 脚本, 事业的是动态作用域.

#### 词法阶段

编译器的第一个工作阶段是词法化, 对源代码中的字符进行检查.
词法作用域就是定义在词法阶段的作用域.
相当于一个个嵌套的“作用域气泡”, 但是不存在交叉.
作用域查找的时候, 会在找到第一个匹配的标识符时停止.(遮蔽效应)
当然, 如果内层有一个变量, 同时这个变量在全局作用域里面也有定义, 那么, 可以通过 window.a 来对其进行访问.

#### 欺骗词法

欺骗词法作用域会导致性能下降.

##### eval

setTimeout, setInterval 的第一个参数如果是字符串, 也可以达到 eval 的效果, new Function()也是, 不过, 这些应该尽量避免使用.

##### with

##### 性能

js 引擎会在编译阶段对代码进行优化, 优化的是静态分析之后的代码. 如果使用了 eval 等等欺骗手段, js 的优化将不太有效率, 甚至引擎会完全不做优化.

### 第三章 函数作用域和块作用域

10:17--11:03
p21--36

究竟是什么生成了一个新的气泡? 只有函数会生成新的气泡吗? js 中其他结构能生成作用域气泡吗?

#### 函数中的作用域

常见的答案: js 具有给予函数的作用域, 只有函数会生成作用域气泡.
这个答案不完全正确.
函数作用域的含义是指, 属于这个函数的全部变量, 都会在整个函数的范围内使用以及复用.

#### 隐藏内部实现

最小特权原则.
规避冲突, 例如循环的时候, 不要修改 i, 但是, var i = 3 就可以, 因为有遮蔽效应.
规避变量冲突的方法有:

1. 全局命名空间,通常是一个变量, 其他需要的变量都在这个命名空间内, 而不是在全局变量内
2. 模块管理

#### 函数作用域

如果在 function 中 var 再次定义全局作用域中的变量, 会“污染”全局作用域中的变量, 解决方法是使用立即执行函数表达式, 例如

```js
var a = 2(function foo() {
  var a = 3;
  console.log(a); // 3
})();
console.log(a); // 2
```

这里其实就是一个表达式, 不会“污染”, foo 变量也不会在全局作用域中被访问到.

##### 具名和匿名

匿名函数写起来比较简便, 但是有一些缺点:

1. 在栈追踪的时候, 不会显示函数名
2. 如果需要引用自身, 那么只能使用 argumengs.callee
3. 可读性可能不佳

#### 块作用域

try/catch 是一种块作用域, 声明的变量只在 catch 里面有效, 例如

```js
try {
  undefined(); // 制造一个异常
} catch (err) {
  console.log(err); // 可以访问err
}
console.log(err); // 不可以访问err
```

let 也可以, 通常是将变量作用域定义在{}内部.
同时, let 和 var 的区别在于, 例如

```js
console.log(a); // undefined
var a = 2;

console.log(b); // ReferenceError
let b = 3; // 可能是所谓的 暂时性死区
```

const 和 let 类似

13:30--14:20
p37-44

### 第四章 提升

任何生命在某个作用域内的变量, 都将附属于这个作用域.
同时, 作用域和变量声明出现的位置有一些联系.

#### js 程序的执行顺序

js 并不总是一行一行地顺序执行的, 例如

```js
a = 2;
var a;
console.log(a); // 2, 如果是顺序执行, 应该是undefined
```

#### 从编译器的角度来解析

总的来说, 由于 js 程序运行前会编译, 编译的时候会先找到所有的声明, 确定它们的作用域, 所以, js 程序运行的时候, 都是先有声明(提升), 后有赋值, 上面的例子可以这样理解:

```js
var a;
a = 2;
console.log(a);
```

但是, 这个提升是 一个作用域 里面的, 并不会穿透, 只会在自己的作用域气泡里面提升, 例如, 函数里面的 var, 不会在全局作用域里面有效.

注意, 函数声明也是会提升的, 比变量提升优先级高, 同时, 如果有多个一样的函数声明(函数名相同) 后面的声明会覆盖前面的.

### 第五章 作用域闭包

#### 什么是闭包

js 中, 闭包无处不在, 我们只需要能够识别并拥抱它.
闭包是给予词法作用域书写代码时候所产生的自然结果.

#### 实质问题

当函数可以记住并且访问所在的词法作用域时, 就产生了闭包, 函数是在当前词法作用域之外执行的.

```js
function foo() {
  var a = 2;
  function bar() {
    console.log(a);
  }
  return bar;
}
var baz = foo();
baz(); // 2, 闭包
```

foo()返回的其实是 bar 函数, baz 其实是 bar 函数的一个引用, baz()这样调用的时候, 相当于 bar(), 但是, 需要特别注意的是, bar 的词法作用域是在 foo 里面的, 现在由于有一个 baz 引用它, 它可以在 baz 所在的词法作用域发挥作用, 而且不会被垃圾回收程序回收.

闭包使得函数可以继续访问定义时的词法作用域.

22:40-23:21
p45-50

```js
var fn;
function foo() {
  var a = 2;
  function baz() {
    console.log(a);
  }
  fn = baz;
}

function bar() {
  fn(); // 闭包
}

foo();
bar(); // 2
```

#### 理解闭包

```js
function wait(message) {
  setTimeout(function timer() {
    console.log(message);
  }, 1000);
}
// 这个就是闭包
```

只要使用了回调函数, 实际上就是使用了闭包.

#### 循环和闭包

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}

for (var i = 1; i <= 5; i++) {
  (function() {
    setTimeout(function timer() {
      console.log(i);
    }, i * 1000);
  })();
}
// 这里的IIFE只是一个什么都没有的作用域, 最后引用的i, 仍然是6

for (var i = 1; i <= 5; i++) {
  (function() {
    var j = i;
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })();
}
```

11:23--11:52
20:27--21:31
p50-64

#### 重新以块作用域的角度思考

上面 IIFE 在迭代的时候, 都创建了一个新的作用域, 也就是说, 我们需要的是一个 块作用域 , 所以用 let 也是可以的.

```js
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, 1000);
}
```

如果如上图一样, 在 for 里面使用 let 定义 i, 那么, 每次循环的时候, 其实都是重新定义 i.

#### 模块

模块其实就是闭包的应用!! module.export 出来的东西就是闭包里面 return 的 function, 里面有一些状态变量, 这样就可以保存状态!

模块模式需要两个必要条件:

1. 必须有外部的封闭函数, 改函数必须被调用一次(每次调用都会创建一个新的模块)
2. 封闭函数必须返回至少一个内部函数, 注意内部函数才能在私有作用域中形成闭包, 同时可以访问或者修改私有状态

模块模式的应用:

1. 模块函数也是函数, 可以传入参数
2. export 一个修改模块内部属性的 api, 类似 vuex, 应该说, vuex 等等状态管理, 其实就是模块模式的应用.

##### 现代的模块机制

##### 未来的模块机制

上面两个并不是十分明白, 先忽略, 看其他先
2019-2-18

### 附录 A 动态作用域

```js
function foo() {
  console.log(a); // 由于所有都是先声明后调用, 其实在bar中, 调用foo的时候, 引用的是全局的a, a=2
}

function bar() {
  var a = 3;
  foo();
}

var a = 2;
bar(); // 词法作用域, 2

function x() {
  var a = 3;
  function y() {
    console.log(a);
  }
  return y();
}

var a = 2;
x(); // 闭包, 3
```

js 只具有词法作用域, 没有动态作用域. 但是, this, 在某种程度上, 很像动态作用域, 而动态作用域关心的是函数从何处调用.

### 附录 B 块作用域的替代方案

es6 下, 使用 let 可以完美实现块作用域, 但是, 如果是前面的版本, 那么, 可能需要使用 try/catch 这样的方式来实现, 例如:

```js
{
  let a = 2;
  console.log(a); // 2
}

console.log(a); // ReferenceError

try {
  throw 3;
} catch (b) {
  console.log(b); // 3, 因为catch是块作用域
}
console.log(b); // ReferenceError
```

#### Traceur

一些 es6 语法转换的项目, 其实都是使用 try/catch 来模拟块作用域的

#### 使用显式 let 块作用域的好处

```js
// 注意, 并不是所有浏览器都支持这种写法
let (a = 2) {
  console.log(a) // 2
}
console.log(a) // ReferenceError
```

1. 更加突出
2. 代码重构的时候也表现得更加健壮

#### 代码性能

其实不需要担心了, 而且, 如果有需要使用块作用域的时候, 就使用 let, 不然, 继续使用 var 也是可以的

### 附录 C this 词法

es6 的箭头函数

1. function 的简写
2. 解决 this 的绑定问题(以往的实现方法是 var self = this)

es6 的箭头函数引入了 this 词法的行为.

```js
var obj = {
  count: 0,
  cool: function coolFn() {
    console.log("outer", this.count);
    if (this.count < 1) {
      setTimeout(() => {
        this.count++;
        console.log("awesome?!");
      }, 100);
    } else {
      setInterval(() => {
        console.log("this.count", this.count);
      }, 500);
    }
  }
};

obj.cool(); // 输出awesome?!, 箭头函数并不是普通的this绑定规则(谁调用指向谁), 而是使用了当前的词法作用域覆盖了this本来的值
```

箭头函数是将程序员们经常范的一个错误(混淆 this 绑定规则和词法作用域规则)给标准化了.
