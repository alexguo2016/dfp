## 你不知道的 JavaScript 上卷

这套书的目的是: 知其然而知其所以然

13:50--14:34
P1--10

### 第一章, 作用域是什么

变量, 将状态带给了程序.
这里会讲到的是, 变量储存在哪里? 程序需要它们的时候, 如何找到它们?

#### 编译原理

事实上 javascript 是一门编译语言.
它不是提前编译的, 编译结果也不能在分布式系统中进行移植.

在编译语言的流程中, 源代码在执行之前的三个步骤--编译:

1. 分词/词法分析(Tokenizing/Lexing)
   将字符串分解成对语言来说有意义的代码块--词法单元(token), 例如: var a = 2-->var, a, =, 2, 空格

2. 解析/语法分析(Parsing)
   讲词法单元流(数组)转换成逐级嵌套组成的程序语法结构的树, 抽象语法树(AST).

3. 代码生成
   将 AST 转换成可执行的代码, 即转化成一族机器指令.

JavaScript 引擎比起上面的步骤要复杂. 例如在词法分析和代码生成阶段都有特定的步骤进行性能优化, 例如对冗余元素进行优化等等.
js 和其他编译语言不同的是, 他的编译在代码执行前的几微秒内完成, 所以它使用了例如 JIT 等等技术来保证性能最佳. 几乎是编译程序之后马上就执行.

#### 理解作用域

需要理解的角色

1. 引擎, 整个 js 程序的编译和执行过程
1. 编译器, 服装语法分析和代码生成等等
1. 作用域, 负责收集并维护所以声明的标识符, 确定标识符的访问权限

##### 例子, var a = 2

这个程序的伪代码是: 为一个变量分配内存, 命名为 a, 然后将值 2 保存进这个变量.

事实上, 编译器是这样做的

1. 遇到 var a, 先询问作用域中是否有一个 a 的变量, 如果有, 进行下一步, 如果没有, 会在 当前作用域 中声明一个新的变量, 命名为 a
2. 处理 a = 2, 这个赋值操作.引擎先问作用域, 当前的作用域集合里面是否有 a 变量, 有, 就使用它, 没有, 就继续查找 a

##### 编译器的工作

在刚刚的例子中, 引起执行程序的时候, 会通过查找变量 a 是否已经声明过, 这个过程中, 会对 a 进行 LHS 查询.
当变量在 赋值操作符的左侧的时候, 对其进行 LHS 查询, 在右侧的时候, 进行 RHS 查询.

- LHS, 试图找到变量的容器本身, 从而可以对其进行赋值, 例如 a = 2, 我们不关心 a 当前是什么, 只是取得他的地址
- RHS, “非左侧”, 就是简单地查找某个变量的值, retrieve his source value, 例如 console.log(a), 这里只是查找并取得 a 的值

##### 引擎和作用域之间的交互

```js
function foo(a) {
  console.log(a);
}
foo(2);
```

既有 LHS 也有 RHS
注意, foo(2)里面隐含了一个 a = 2 的 LHS

22:00--22:30
22:51--23:11
P10-20

#### 作用域嵌套

在实际情况中, 通常需要同时顾及几个作用域. 可能会出现作用域嵌套的情况.
如果在当前作用域无法找到某个变量, 就会去外层作用域中查找, 直到抵达最外层的作用域为止.

#### 异常

LHS 和 RHS 是不同的.
在非严格模式下, 如果 LHS 找不到变量名, 引擎会在全局作用域里面声明该变量.
但是, 如果 RHS, 当找不到对应的变量, 引擎就会抛出一个异常, ReferenceError, 如果对该变量进行不合理操作, 就会抛出 TypeError.

### 第二章 词法作用域

js 使用的是词法作用域, 也是大多数编程语言使用的, 其他语言例如 Bash 脚本, 事业的是动态作用域.

#### 词法阶段

编译器的第一个工作阶段是词法化, 对源代码中的字符进行检查.
词法作用域就是定义在词法阶段的作用域.
相当于一个个嵌套的“作用域气泡”, 但是不存在交叉.
作用域查找的时候, 会在找到第一个匹配的标识符时停止.(遮蔽效应)
当然, 如果内层有一个变量, 同时这个变量在全局作用域里面也有定义, 那么, 可以通过 window.a 来对其进行访问.

#### 欺骗词法

欺骗词法作用域会导致性能下降.

##### eval

setTimeout, setInterval 的第一个参数如果是字符串, 也可以达到 eval 的效果, new Function()也是, 不过, 这些应该尽量避免使用.

##### with

##### 性能

js 引擎会在编译阶段对代码进行优化, 优化的是静态分析之后的代码. 如果使用了 eval 等等欺骗手段, js 的优化将不太有效率, 甚至引擎会完全不做优化.

### 第三章 函数作用域和块作用域

#### 函数中的作用域

#### 隐藏内部实现

#### 函数作用域

#### 块作用域
