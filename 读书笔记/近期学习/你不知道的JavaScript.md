## 你不知道的 JavaScript 上卷

这套书的目的是: 知其然而知其所以然

13:50--14:34
P1--10

### 第一章, 作用域是什么

变量, 将状态带给了程序.
这里会讲到的是, 变量储存在哪里? 程序需要它们的时候, 如何找到它们?

#### 编译原理

事实上 javascript 是一门编译语言.
它不是提前编译的, 编译结果也不能在分布式系统中进行移植.

在编译语言的流程中, 源代码在执行之前的三个步骤--编译:

1. 分词/词法分析(Tokenizing/Lexing)
   将字符串分解成对语言来说有意义的代码块--词法单元(token), 例如: var a = 2-->var, a, =, 2, 空格

2. 解析/语法分析(Parsing)
   讲词法单元流(数组)转换成逐级嵌套组成的程序语法结构的树, 抽象语法树(AST).

3. 代码生成
   将 AST 转换成可执行的代码, 即转化成一族机器指令.

JavaScript 引擎比起上面的步骤要复杂. 例如在词法分析和代码生成阶段都有特定的步骤进行性能优化, 例如对冗余元素进行优化等等.
js 和其他编译语言不同的是, 他的编译在代码执行前的几微秒内完成, 所以它使用了例如 JIT 等等技术来保证性能最佳. 几乎是编译程序之后马上就执行.

#### 理解作用域

需要理解的角色

1. 引擎, 整个 js 程序的编译和执行过程
1. 编译器, 服装语法分析和代码生成等等
1. 作用域, 负责收集并维护所以声明的标识符, 确定标识符的访问权限

##### 例子, var a = 2

这个程序的伪代码是: 为一个变量分配内存, 命名为 a, 然后将值 2 保存进这个变量.

事实上, 编译器是这样做的

1. 遇到 var a, 先询问作用域中是否有一个 a 的变量, 如果有, 进行下一步, 如果没有, 会在 当前作用域 中声明一个新的变量, 命名为 a
2. 处理 a = 2, 这个赋值操作.引擎先问作用域, 当前的作用域集合里面是否有 a 变量, 有, 就使用它, 没有, 就继续查找 a

##### 编译器的工作

在刚刚的例子中, 引起执行程序的时候, 会通过查找变量 a 是否已经声明过, 这个过程中, 会对 a 进行 LHS 查询.
当变量在 赋值操作符的左侧的时候, 对其进行 LHS 查询, 在右侧的时候, 进行 RHS 查询.

- LHS, 试图找到变量的容器本身, 从而可以对其进行赋值, 例如 a = 2, 我们不关心 a 当前是什么, 只是取得他的地址
- RHS, “非左侧”, 就是简单地查找某个变量的值, retrieve his source value, 例如 console.log(a), 这里只是查找并取得 a 的值

##### 引擎和作用域之间的交互

```js
function foo(a) {
  console.log(a);
}
foo(2);
```

既有 LHS 也有 RHS

#### 作用域嵌套

#### 异常
