# 第一章 构造过程抽象
## 1.1 程序设计的基本元素
每一种有力的语言, 都为将 简单的认识组合成更负责认识的方法提供了以下3个机制:
1. 基本表达形式, 表示最简单的个体
2. 组合的方法, 可以将简单个体组合成复合元素
3. 抽象的方法, 可以为复合的对象命名, 将其当作单元去操作

数值处理一点都不简单: 不同的数据类型使人迷惑和犯错.

计算过程的Lisp描述本身又可以作为Lisp的数据来表述和操作. 这个到底是什么意思?

将运算符放在所有运算对象的左边, 称为“前缀表示”.
它可以完全适用于可能带有任意哥实参的过程.

Scheme里面, 可以使用例如 (define size 2) 来定义一个变量.

组合式的求值过程, 就是从树的最下面开始, 一层层向上传递值, 称为“树形积累”.

过程定义, 可以这样定义一个函数 (过程) : (define (square x) (* x x)).
看起来和箭头函数很类似.

代换模型. 一步步将过程替换成已知的东西.
有两种不同的的求值方式:
1. “完全展开后归约”---正则序求值
2. “先求值参数而后应用”--应用序求值

Lisp采用应用序求值. 避免对于表达式的重复求值.

分情况分析: (if)
(define (abs x)
	(cond (> x 0) x)
	((= x 0) 0)
	(< x 0) (-x))
从上而下来求值, 如果有条件符合, 则返回相应的结果. 如果没有符合的条件, 则cond的值就没有定义.
(define (abs x)
	(cond ((< x 0) (-x))
	(else x)))
这个是使用了else的形式.
(define (abs x)
	(if (< x 0)
		(-x)
		x))
其他符合运算符
(and x y z)
(or x y z)
(not x)
这些用法和其他编程语言一致.

练习1.1 普通的书写练习
练习1.2 深层次的前缀形式变换
练习1.3 函数的定义, 可以使用高阶函数
练习1.4 就算连前缀的运算符号, 也是可以使用if的
练习1.5 应用序比较符合人类直觉, 正则序有可能会有如题目一样的死循环问题

练习1.6-1.8 暂时不知道怎么解决

内部定义和块结构
过程里面有自己的定义, 不会被其他过程使用到. 这样做, 就不会污染全局作用域.
也不需要在使用主要过程的时候, 不停地引用其他过程.
用户只需要关注其中自己最需要的部分即可, 其实不需要知道这个过程里面的具体实现是怎样的. 
过程也可以使用已经有的其他定义.

## 1.2 过程和它们所产生的计算

懂得编写过程, 只是如学习下棋一般, 只了解了棋子的移动方式, 但是, 并不会典型的开局、 战术和策略.

一个过程也就是一种模式, 它描述了一个计算过程的局部演化方式, 描述了这一计算过程中的每个步骤是怎样基于前面的步骤建立起来的.

接下来考察这些简单过程所缠上的计算过程的“形状”, 还将研究这些计算过程需要消耗的计算资源的速率.

计算阶乘的两种不同方法:
1. 使用之前的“代换模型”, 一步步代换下来. 这个是递归计算, 需要保存的信息量随着n而线性增长. 这是线性递归过程.
2. 使用循环. 首先计算1*2, 保存结果, 后面使用结果*3 ----> 直到大于n为止. 需要的变量只有固定个数, 这个是线性迭代计算过程.

不要搞混了递归计算过程的概念和递归过程的概念.
递归是指: 这个过程的定义中, 引用了该过程本身. 在说某个计算过程的时候, 说的是这个计算过程的进展方式.

